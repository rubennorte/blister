{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "src/blister.js",
    "src/wrappers.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "'use strict';\n\nvar wrappers = require('./wrappers');\n\n/**\n * @name BlisterDependencyType\n * @enum {string}\n *\n * @property {string} VALUE\n * @property {string} SINGLETON\n * @property {string} FACTORY\n */\n\nvar VALUE = 'VALUE';\nvar SINGLETON = 'SINGLETON';\nvar FACTORY = 'FACTORY';\n\n/**\n * Dependency injection container constructor\n *\n * @example\n * var container = new BlisterContainer();\n * container.set('id', 'value');\n * container.get('id'); //> 'value';\n *\n * @class\n */\nfunction BlisterContainer() {\n  this._deps = {};\n}\n\nBlisterContainer.prototype = {\n\n  constructor: BlisterContainer,\n\n  /**\n   * Type for VALUE dependencies.\n   * It is the default type for dependencies specified as primitives: strings,\n   * numbers, booleans, etc.\n   *\n   * @constant {string}\n   */\n  VALUE: VALUE,\n\n  /**\n   * Type for SINGLETON dependencies.\n   * It is the default type for dependencies specified as functions\n   *\n   * @constant {string}\n   */\n  SINGLETON: SINGLETON,\n\n  /**\n   * Type for FACTORY dependencies\n   *\n   * @constant {string}\n   */\n  FACTORY: FACTORY,\n\n  /**\n   * Returns the dependency set with the given id,\n   * or undefined if it is not present\n   * @param  {string} id\n   * @return {*}\n   */\n  get: function(id) {\n    var wrapper = this._deps[id];\n    return wrapper && wrapper(this);\n  },\n\n  /**\n   * Registers the specified dependency in the container with the given type.\n   *\n   * If no type is passed, the default is SINGLETON for functions and\n   * VALUE for others.\n   * If the type is VALUE, the given value is returned each time the dependency\n   * is requested.\n   * If the type is SINGLETON, the given function will be called the first time\n   * the dependency is requested. The value is returned and cached for the\n   * subsequent calls.\n   * If the type is FACTORY, the given function is called each time the\n   * dependency is requested.\n   *\n   * @param {string} id The dependency id\n   * @param {*|Function} [value] The dependency definition\n   * @param {BlisterDependencyType} [type] VALUE, SINGLETON or FACTORY\n   *                                       properties\n   * @return {BlisterContainer} The container itself\n   */\n  set: function(id, value, type) {\n    return this._set(id, value, type);\n  },\n\n  /**\n   * Extends the specified dependency in the container with the given type.\n   *\n   * If no type is passed, inherits the original type if it is a function or\n   * it is defined as VALUE otherwise.\n   *\n   * @param {string} id The dependency id\n   * @param {*|Function} [value] The dependency definition\n   * @param {BlisterDependencyType} [type] VALUE, SINGLETON or FACTORY\n   *                                       properties\n   * @return {BlisterContainer} The container itself\n   */\n  extend: function(id, value, type) {\n    if (!this._deps[id]) {\n      throw new Error('Cannot extend a dependency not previously set: ' + id);\n    }\n\n    return this._set(id, value, type, true);\n  },\n\n  /**\n   * Internal dependency setter that adds extension support\n   *\n   * @private\n   * @param {string} id The dependency id\n   * @param {*|Function} [value] The dependency definition\n   * @param {BlisterDependencyType} [type] VALUE, SINGLETON or FACTORY\n   *                                       properties\n   * @param {boolean} isExtension Determines if extends a previous dependency,\n   *                              so the original value is stored and passed to\n   *                              the new definition\n   * @return {BlisterContainer} The container itself\n   */\n  _set: function(id, value, type, isExtension) {\n    if (typeof id !== 'string') {\n      throw new TypeError('The dependency id must be a string: ' + id);\n    }\n\n    var originalWrapper = isExtension ? this._deps[id] : undefined;\n\n    var typeOfValue = typeof value;\n    if (!type) {\n      if (typeOfValue !== 'function') {\n        type = VALUE;\n      } else if (isExtension) {\n        type = originalWrapper.type;\n      } else {\n        type = SINGLETON;\n      }\n    }\n\n    if (typeOfValue !== 'function' && type !== VALUE) {\n      throw new TypeError(\n        'The value must be a function for types SINGLETON and FACTORY: ' +\n        value);\n    }\n\n    this._deps[id] = wrappers.create(type, value, this, originalWrapper);\n    return this;\n  },\n\n  /**\n   * Calls register on the given service provider to register its dependencies\n   * @param  {BlisterServiceProvider} provider\n   * @return {BlisterContainer} the container itself\n   */\n  register: function(provider) {\n    provider.register(this);\n    return this;\n  }\n\n};\n\n/**\n * Interface for service providers to use with BlisterContainer instances\n *\n * @interface BlisterServiceProvider\n *\n * @example\n *\n * // @implements {BlisterServiceProvider}\n * var provider = {\n *  register: function(container) {\n *    container.set('protocol', 'http://');\n *    container.set('host', 'example.com');\n *  }\n * };\n *\n * var container = new BlisterContainer();\n * container.register(provider);\n */\n\n/**\n * @function\n * @name BlisterServiceProvider#register\n * @description Registers an indeterminate number of dependencies in the passed\n *              container\n * @param {BlisterContainer} container\n */\n\nmodule.exports = BlisterContainer;\n",
    "'use strict';\n\n/**\n * Wrapper functions to store the different types of dependencies in the\n * container\n * @private\n * @type {Object}\n */\nvar wrappers = {\n\n  /**\n   * Returns a wrapper for a VALUE dependency to be stored in the container\n   * @param {*} value\n   * @return {Function}\n   */\n  VALUE: function wrapValue(value) {\n    return function() {\n      return value;\n    };\n  },\n\n  /**\n   * Returns a wrapper for a FACTORY dependency to be stored in the container\n   * @param {Function} value The factory function\n   * @param {BlisterContainer} container\n   * @param {Function} [originalWrapper]\n   * @return {Function}\n   */\n  FACTORY: function wrapFactory(value, container, originalWrapper) {\n    return function() {\n      var originalValue = originalWrapper && originalWrapper();\n      return value.call(container, container, originalValue);\n    };\n  },\n\n  /**\n   * Returns a wrapper for a SINGLETON dependency to be stored in the container\n   * @param {Function} value The singleton generator function\n   * @param {BlisterContainer} container\n   * @param {Function} [originalWrapper]\n   * @return {Function}\n   */\n  SINGLETON: function wrapSingleton(value, container, originalWrapper) {\n    var cached = false;\n    var cachedValue;\n    return function() {\n      var originalValue;\n      if (!cached) {\n        cached = true;\n        originalValue = originalWrapper && originalWrapper();\n        cachedValue = value.call(container, container, originalValue);\n        value = null;\n      }\n      return cachedValue;\n    };\n  },\n\n  /**\n   * Returns a wrapper for the given parameters\n   * @param  {BlisterDependencyType} type\n   * @param  {*|Function} value\n   * @param  {BlisterContainer} container\n   * @param  {Function} [originalWrapper]\n   * @return {Function}\n   */\n  create: function(type, value, container, originalWrapper) {\n    var wrapper = this[type](value, container, originalWrapper);\n    wrapper.type = type;\n    return wrapper;\n  }\n\n};\n\nmodule.exports = wrappers;\n"
  ]
}